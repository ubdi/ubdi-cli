const prompts = require('prompts')
const simpleGit = require('simple-git')
const chalk = require('chalk')
const ora = require('ora')

const apps = require('./apps/apps')
const appSpecificCode = require('./apps')
const {
  getTags,
  getDiffSinceLastTag,
  checkoutMaster,
  tagAndPush
} = require('./utils')
const { execBash, tag, loadConfig } = require('../../utils')

const output = console.log // eslint-disable-line no-console

const outputDiff = diff => {
  output(chalk.underline('Here are the commits that you are about to release:'))
  diff.map(({ message, author_name }) =>
    output(`+ ${chalk.green(message)} by ${author_name}`)
  )
}

// Main fns
const releaseApp = async app => {
  const paths = await loadConfig(apps.map(({ name }) => name))

  output('\n')
  const oraPull = ora('Pulling repo and fetching tags...').start()
  const repo = simpleGit(paths[app.name])

  await checkoutMaster(repo)

  const tags = await getTags(repo)
  const newTag = tag.generateTagName(tags.all)

  // NOTE: mobile apps have different release tracks, hence special handling here
  // This can possibly be abstracted into general handling, e.g: have rules that
  // lead to each release track, and then just check the rules here and divert to proper cmds
  let latestTag = tags.latest
  let releaseCommands

  // Check if app has some custom code for releasing
  if (appSpecificCode[app.name]) {
    const appSpecificResult = await appSpecificCode[app.name]({
      app,
      repo,
      tags
    })

    if (appSpecificResult.latestTag) {
      latestTag = appSpecificResult.latestTag
    }

    if (appSpecificResult.releaseCommands) {
      releaseCommands = appSpecificResult.releaseCommands
    }
  }

  // Diff handling
  const diff = await getDiffSinceLastTag(repo, latestTag)
  oraPull.stop()

  if (diff.total === 0) {
    return output(
      chalk.yellow(
        `There is nothing new to be released for the app ${app.displayName}.`
      )
    )
  }

  outputDiff(diff.all)

  const { confirmed } = await prompts({
    type: 'toggle',
    name: 'confirmed',
    message: `Can you confirm this? ${
      !app.skipTag
        ? `Tag name will be ${newTag}`
        : 'Tag will be generated by child commands.'
    }`,
    initial: true,
    active: 'yes',
    inactive: 'no'
  })

  if (!confirmed) return output(chalk.yellow('K, thx, bye.'))

  // Handling of dependent apps
  if (app.dependencies.length > 0) {
    output(
      chalk.magenta(
        `The app ${app.displayName} has apps dependent on it, we suggest to deploy them as well`
      )
    )

    const { selectedApps } = await prompts({
      type: 'multiselect',
      name: 'selectedApps',
      message: 'Select the apps you want to deploy:',
      choices: apps
        .filter(({ name }) => app.dependencies.includes(name))
        .map(app => ({
          title: app.displayName,
          value: app,
          selected: true
        }))
    })

    await Promise.all(selectedApps.map(app => releaseApp(app)))
  }

  if (!app.skipTag) {
    const oraTagAndPush = ora('Tagging and pushing...').start()

    await tagAndPush(repo, newTag)

    oraTagAndPush.succeed(`Released ${app.displayName}!`)
  }

  if (releaseCommands) {
    const oraCommands = ora('Running custom commands...').start()

    for (const cmd of releaseCommands) {
      const oraCommand = ora(
        chalk.green(`\nRunning ${cmd} in ${paths[app.name]} \n`)
      ).start()
      const result = await execBash(`cd ${paths[app.name]} && ${cmd}`)
      output(result)
      oraCommand.succeed('âœ…')
    }

    oraCommands.succeed('All commands completed')
  }

  output(chalk.green('My job here is done! Allahimanet.'))
}

module.exports = {
  command: 'release',
  description: 'Releases UBDI apps',
  exec: async () => {
    const { app } = await prompts({
      type: 'select',
      name: 'app',
      message: 'Which app do you want to deploy?',
      choices: apps.map(app => ({
        title: app.displayName,
        value: app
      }))
    })

    if (!app) output(chalk.red('OK, no problem. I am not angry.'))

    await releaseApp(app)
  }
}
